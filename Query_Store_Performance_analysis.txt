CREATE PROCEDURE dbo.usp_GetQueryStoreDailyMetricsPivot
    @Days INT = 10,
    @QueryID BIGINT = NULL,
    @SqlText NVARCHAR(MAX) = NULL,
    @DurationThreshold NVARCHAR(20) = NULL  -- e.g. '20s' for 20 seconds, '4m' for 4 minutes
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @cols NVARCHAR(MAX),
            @query NVARCHAR(MAX),
            @DurationValue DECIMAL(18,3) = NULL,
            @DurationMultiplier BIGINT = NULL,
            @ThresholdMs DECIMAL(18,3) = NULL;  -- threshold in milliseconds

    -- Parse the duration threshold if provided.
    IF (@DurationThreshold IS NOT NULL AND LEN(@DurationThreshold) > 0)
    BEGIN
        IF RIGHT(@DurationThreshold,1) IN ('s','S')
        BEGIN
            SET @DurationValue = TRY_CONVERT(DECIMAL(18,3), LEFT(@DurationThreshold, LEN(@DurationThreshold)-1));
            SET @DurationMultiplier = 1000000;  -- 1 second = 1,000,000 microseconds
        END
        ELSE IF RIGHT(@DurationThreshold,1) IN ('m','M')
        BEGIN
            SET @DurationValue = TRY_CONVERT(DECIMAL(18,3), LEFT(@DurationThreshold, LEN(@DurationThreshold)-1));
            SET @DurationMultiplier = 60000000; -- 1 minute = 60,000,000 microseconds
        END
        ELSE
        BEGIN
            -- Assume minutes if no suffix is provided.
            SET @DurationValue = TRY_CONVERT(DECIMAL(18,3), @DurationThreshold);
            SET @DurationMultiplier = 60000000;
        END
        -- Convert threshold into milliseconds.
        SET @ThresholdMs = (@DurationValue * @DurationMultiplier) / 1000.0;
    END;

    -- Generate a list of the past @Days dates (formatted as 'YYYY-MM-DD')
    ;WITH DayNumbers AS (
         SELECT TOP (@Days) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1 AS n
         FROM sys.all_objects  -- Assumes sufficient rows exist
    ),
    LastNDays AS (
         SELECT CONVERT(VARCHAR(10), CAST(DATEADD(day, -n, CAST(GETDATE() AS DATE)) AS DATE), 120) AS ExecutionDate
         FROM DayNumbers
    )
    SELECT @cols = STRING_AGG(QUOTENAME(ExecutionDate), ',')
    FROM LastNDays;

    /*
      Build the dynamic SQL:
      1. DailyStats CTE aggregates the metrics per query per day.
      2. If a threshold was provided, QualifiedQueries CTE identifies queries that qualified 
         on at least one day (i.e. having MaxDurationMs >= @ThresholdMs).
      3. In the final SELECT, we pivot the daily metrics so each day becomes a column.
    */
    SET @query = N'
WITH DailyStats AS (
    SELECT
        q.query_id,
        qt.query_sql_text,
        CONVERT(VARCHAR(10), CAST(rsi.start_time AS DATE), 120) AS ExecutionDate,
        SUM(rts.count_executions) AS ExecCount,
        ROUND(MAX(rts.max_duration)/1000.0, 3) AS MaxDurationMs,
        ROUND(MIN(rts.min_duration)/1000.0, 3) AS MinDurationMs,
        ROUND(AVG(rts.avg_duration)/1000.0, 3) AS AvgDurationMs
    FROM sys.query_store_query AS q
    INNER JOIN sys.query_store_plan AS p
         ON q.query_id = p.query_id
    INNER JOIN sys.query_store_runtime_stats AS rts
         ON p.plan_id = rts.plan_id
    INNER JOIN sys.query_store_runtime_stats_interval AS rsi
         ON rts.runtime_stats_interval_id = rsi.runtime_stats_interval_id
    INNER JOIN sys.query_store_query_text AS qt
         ON q.query_text_id = qt.query_text_id
    WHERE rsi.start_time >= DATEADD(day, -' + CONVERT(NVARCHAR(10), @Days) + ', GETDATE())
';

    -- Append filter on QueryID if provided.
    IF @QueryID IS NOT NULL
        SET @query = @query + ' AND q.query_id = ' + CONVERT(NVARCHAR(20), @QueryID);

    -- Append filter on SQL text if provided.
    IF @SqlText IS NOT NULL AND LEN(@SqlText) > 0
        SET @query = @query + ' AND qt.query_sql_text LIKE ''%' + REPLACE(@SqlText, '''', '''''') + '%''';

    SET @query = @query + '
    GROUP BY q.query_id, qt.query_sql_text, CAST(rsi.start_time AS DATE)
)
';

    IF @ThresholdMs IS NOT NULL
    BEGIN
        SET @query = @query + ',
QualifiedQueries AS (
    SELECT DISTINCT query_id
    FROM DailyStats
    WHERE MaxDurationMs >= @ThresholdMs
)
SELECT 
    pvt.query_id,
    pvt.query_sql_text, 
    ' + @cols + '
FROM (
    SELECT 
         ds.query_id,
         ds.query_sql_text,
         ds.ExecutionDate,
         ''Exec:'' + CONVERT(VARCHAR(20), ds.ExecCount)
         + '', Max:'' + FORMAT(ds.MaxDurationMs, ''0.000'')
         + '', Min:'' + FORMAT(ds.MinDurationMs, ''0.000'')
         + '', Avg:'' + FORMAT(ds.AvgDurationMs, ''0.000'') AS DailyMetrics
    FROM DailyStats ds
    INNER JOIN QualifiedQueries qq
         ON ds.query_id = qq.query_id
) AS src
PIVOT (
    MAX(DailyMetrics)
    FOR ExecutionDate IN (' + @cols + ')
) AS pvt
ORDER BY pvt.query_id;
';
    END
    ELSE
    BEGIN
        SET @query = @query + '
SELECT 
    pvt.query_id,
    pvt.query_sql_text, 
    ' + @cols + '
FROM (
    SELECT 
         ds.query_id,
         ds.query_sql_text,
         ds.ExecutionDate,
         ''Exec:'' + CONVERT(VARCHAR(20), ds.ExecCount)
         + '', Max:'' + FORMAT(ds.MaxDurationMs, ''0.000'')
         + '', Min:'' + FORMAT(ds.MinDurationMs, ''0.000'')
         + '', Avg:'' + FORMAT(ds.AvgDurationMs, ''0.000'') AS DailyMetrics
    FROM DailyStats ds
) AS src
PIVOT (
    MAX(DailyMetrics)
    FOR ExecutionDate IN (' + @cols + ')
) AS pvt
ORDER BY pvt.query_id;
';
    END

    -- Uncomment the following line to debug the dynamic SQL:
    -- PRINT @query;

    EXEC sp_executesql @query,
         N'@ThresholdMs DECIMAL(18,3)',
         @ThresholdMs = @ThresholdMs;
END;
GO
